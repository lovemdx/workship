IO模型：
    问题：程序和系统内核交互数据，采取什么样的策略?阻塞？非阻塞？多路复用？信号？
    定义：input output 任何程序都必须有输入输出 IO是计算机是瓶颈
    注意：C10K当客户端有1万个客户端连接时，就有问题
    内容：
    (1)bio(block IO)  阻塞IO
        内容：在服务端中，线程一直等待链接。链接来了，抛出线程接受客户端，等数据，一直卡着不动，等数据来了再接下来执行。
        BIO中，每个连接对应一个线程，
        优点：让服务器能对应多客户端  
        缺点:线程太多，系统调用比较多，大量CPU资源被占用在资源调度上。
        根本原因：阻塞，大量线程创建了走不了

    (2)nio（NEW IO） java中，newio,OS中，非阻塞
        问题：怎么解决Bio阻塞带来多线程带来的性能问题？
        解决：kernel进化出非阻塞概念！服务器也非阻塞！
            服务器中，原来读服务器阻塞时，一直在等。现在立刻有返回值，-1代表没有，或者具体的客户端放到链表中，用判断写下一步处理客户端的数据。客户端也非阻塞，客户端链表一直被遍历，读到东西就返回，读不到就继续循环链表。

        优点：只有一个线程，规避了多线程，线程调度的资源节省。可以开线程池，把客户端链表切分成多个线程循环 
        缺点：假设一万个连接，只有一个发来数据，但是还是要向内核发送一万次recv系统调用，CPU的cache不断恢复现场，有9999次是无意义的，消耗系统资源的。复杂度在系统调用上



    (3)多路复用器
        问题：怎么解决nio非阻塞客户端多时，频繁调用内核。
        解决：knrnel进化出多路复用器概念！降低调用内核的频率。策略：NIO一次传一个客户端，问有没有返回；干脆把链表中所有client全传给内核，让内核告诉我有哪些可以调用，我再调用，就只调用很少次数的内核了。
            相比nio进化点：内核先判断哪些可读返回，服务器再读
        定义：因为原来是一个client一次，现在是client链表调用一次内核，多个路复用了一个系统调用，所以叫多路复用器

        版本：
            select（fds）
                程序用select多路复用器首先获得client链表的是否有数据可读的状态
                程序再访问内核读取数据 
                同步IO模型：bio,nio,多路复用器 里面才有阻塞，非阻塞
                异步IO模型：如windowIO，程序注册读取程序，内核首先确定状态，再抛出线程读取数据放到程序进程内存中
            poll(fds)
                和select一类，不过select有1024个客户端的限制
                poll没有1024的限制
            select和poll
                优势：相比于nio，解决了频繁调用内核的问题，减少了系统调用的次数
                弊端：1.重复传递fds（内核通过fds访问文件，文件描述符是非负整数），内核没存
                        解决：内核开辟空间保留fds，
                     2，每次select或者poll的时候，都要重新遍历全量的fds才能读。并未完全做到数据来个，主动提醒。还是被动的。
                        解决：计算机组成的深度知识（中断、callback、增强）
            epoll
                优势，相比于poll和select，

    (5)同步异步


计算机系统基础的IO铺垫：
    1.APP通过调用系统内核OS控制硬件。
    2.怎么保证系统内核不被修改破坏：GDT协议，划分内核区和用户应用区

    3.时钟中断：晶震 接入CPU CPU被打断一下，就执行另一个程序
    4.CPU不能停止，只能控制方向。各个IO可以打断CPU
        举例：1.APP代码 print（'打印'）
             2.指令先转化为打断CPU，CPU从IDT找到内核中回调函数的地址  程序不知道内核中回调函数的地址
             3.函数从寄存器中读取参数
             4.执行成功
        优点：既保护了内核，有能调用内核的函数
    5.硬盘有中断，网卡也有中断，应用有中断

    6.程序如果想访问硬件，必须和内核交互，内核暴露系统调用给程序使用system.call。这样保护了内核，但是消耗了资源，会比较慢

    7.无论什么语言写的，什么程序，网络层都是一样的，都是调用内核功能完成网络通信
    8.如果不想通过内核调用，完成多线程的锁的功能，就用CAS，compare and swap(自旋锁)
    