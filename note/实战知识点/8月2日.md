路由模式
    -单页面包括Vue，都有共同的切换模式：hash模式和历史模式。
    -hash模式：
        用#XXX给a的href做标记，用DOM切换display:none
        缺点：分布式微前端中，子系统嵌套，定义url不方便
            -包含一个#，视觉上不美观
    -history模式：用得少
        不需要借助锚点技术重写url路径，路径中没#，视觉上更美观。
        histroy模式采用history对象中的pushState()函数重写url路径，可在触发重新加载的情况下变更URL路径。

str.lastIndexOf() 返回指定字符在字符串最后出现的位置

箭头函数
    -箭头函数的this对象，而是上下文
    -箭头函数的进化：
        function(a){
            return a
        }
        =========》》
        (a)=>{return a}  函数体只有一行也可以省略大括号
        =========>> 
        a => a

Windows Location对象
    .host 返回当前url的域名
    .pathname  当前页面的路径和文件名
    .port    返回web主机的端口（80或443）
    .protocol 返回网页协议，如http或https

array的方法：
    array.pop() 弹出，删除最后一位
    array.push()压栈，添加最后一位
    array.shift() 删除第一位
    array.unshift()  添加第一位

Math.pow(num，num2)
    num^num2次方

<!DOCTYPE> 
    -声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令
    -声明没有结束标签。
    -声明对大小写不敏感。
    -<!DOCTYPE> 声明必须是 HTML 文档的第一行，位于 <html> 标签之前.

js基础数据类型和引用数据类型
    1.存放位置：
        存放在栈内存，被引用或被拷贝时候，会创建一个完全相等的变量，占据空间小，大小固定，属于被频繁使用的数据类型。
        存放在堆内存中，引用数据类型会在栈内存存储数据的地址，当使用引用类型时候，在栈内存获取堆内存地址，然后去堆内存根据地址寻找数据。
    2.三个空间
        js执行过程中，有三种类型的内存空间（代码空间，栈空间，堆空间），代码空间存储可执行的代码，基础类型存储在栈空间，引用类型存储在堆空间，访问引用类型的时候要先去栈空间获取存储地址。

栈和堆的区别
    一、程序的内存分配方式不同
        栈区（stack）：编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构的栈。
        堆区（heap）：一般是由程序员分配释放，若程序员不释放的话，程序结束时可能由OS回收，值得注意的是他与数据结构的堆是两回事，分配方式倒是类似于数据结构的链表。
    二、申请方式不同
        stack 由系统自动分配，heap 需要程序员自己申请。
        C 中用函数 malloc分配空间，用 free 释放，C++用 new 分配，用 delete 释放。
    三、申请后系统的响应不同
        栈：只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。
        堆：首先应该知道操作系统有一个记录内存地址的链表，当系统收到程序的申请时，遍历该链表，寻找第一个空间大于所申请的空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的 delete 或 free 语句就能够正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会将多余的那部分重新放入空闲链表中。
    四、 申请的大小限制不同
        栈：在 windows 下，栈是向低地址扩展的数据结构，是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的，能从栈获得的空间较小。
        堆：堆是向高地址扩展的数据结构，是不连续的内存区域，这是由于系统是由链表在存储空闲内存地址，自然堆就是不连续的内存区域，且链表的遍历也是从低地址向高地址遍历的，堆得大小受限于计算机系统的有效虚拟内存空间，由此空间，堆获得的空间比较灵活，也比较大。
    五、申请的效率不同
        栈：栈由系统自动分配，速度快，但是程序员无法控制。
        堆：堆是有程序员自己分配，速度较慢，容易产生碎片，不过用起来方便。
    六、堆和栈的存储内容不同
        栈：在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令的地址，然后函数的各个参数，在大多数的 C 编译器中，参数是从右往左入栈的，当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令。
        堆：一般是在堆的头部用一个字节存放堆的大小，具体内容由程序员安排。

git

parseFloat()：
    如果 parseFloat 在解析过程中遇到了正号（+）、负号（- U+002D HYPHEN-MINUS）、数字（0-9）、小数点（.）、或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。
    第二个小数点的出现也会使解析停止（在这之前的字符都会被解析）。
    参数首位和末位的空白符会被忽略。
    如果参数字符串的第一个字符不能被解析成为数字，则 parseFloat 返回 NaN。
    parseFloat 也可以解析并返回 Infinity。
    parseFloat 解析 BigInt 为 Numbers, 丢失精度。因为末位 n 字符被丢弃。
    所以并不会把0x当成16进制数字

chrome浏览器进程：
    包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程

浮点数在计算机中的表示方法：
    1.占64位，其中1位表示正负，2-12表示阶位，13-64表示小数位
    0.1+0.2不等于0.3，是因为0.1和0.2在计算时，发生了两次进度丢失

js的基本拿数据类型：null,string,number,boolean,undefined,symbol，bigint

URL的格式：
    协议//主机：端口号/路径名称?搜索条件#哈希标识   
        -#哈希标识 是位置标识，可直接跳转到网页相应位置

valueOf 和 toString
    valueOf():
        -数组：返回数组对象本身
        -函数：返回函数本身
        -对象：返回对象本身
       
        -boolean：返回布尔值
        -num:返回数字
        -字符串：返回字符串值

        -Date：返回毫秒计数
    
    toString（）：
        -Array：返回,分割的字符串，如[1,2]返回1,2
        -Function：声明函数的Js源代码字符串
        -Object：返回[Object，Object]

        -Num：数字字符串形式
        -Boolean：布尔值字符串形式

        -Dtae：返回可读的时间字符串，例如Tue Oct 27 2020 16:08:48 GMT+0800

常用的内存管理方式：
    块式管理：分配一块空间，空间较大，容易浪费，方便管理
    页式管理：比块小，空间利用率大
    段式管理：比页小，利用率大。但是有时候程序被切碎，需要大量用到物理地址，造成浪费
    段页式管理：每个程序分成若干段，每一段分成若干页。取个数据要访问三次内存。

进程的三种状态：就绪、运行、阻塞。一个进程只有三种状态之一
    就绪-》执行：当前运行的进行时间片用完了，调度转到就绪队列选择合适的进程分配CPU
    运行-》就绪：时间片用完
    运行-》阻塞：发生了IO请求，或等待事件发生
    阻塞-》运行  事件完成

原语
    P操作：申请资源，当资源不足的时候，进程阻塞
    V操作：释放资源，不会阻塞


OSPF路由协议


计算数据字段长度、片偏移字段和MF标志
    MTU：1500
    -每段数据IP地址为20字节，数据长度为1480字节。
    -如果后面还有数据包，MF=1，没有MF=0
    -第一个数据包偏移字段为0。后面每有一个数据包，偏移量+ 1480/8 =185

不同的with属性
    HTMLELEMENT.offsetWidth:元素可视区域的大小。包括content,border,padding,滚动条。
    HTMLELEMENT.clientWidth:元素展示内容大小。包括content
    HTMLELEMENT.scrollWidth:元素包括overflow内容的大小。

===和==
    ===判断规则：
        1.类型不相同，就false
        2.如果是同一个数值，则相等。
            -如果有一个NaN,那么不相等
        3.都是字符串，且相同，则true
        4.都是布尔值，且相同，则true
        5.引用同一个对象或函数，则true
        6.如果都是null和undefined，则true

    ==判断规则：
        1.如果两个值类型相同，用===比较
        2.类型不同也有可能相等
            -一个null一个undefined，则相等
            -一个字符串一个数字，字符串转化为数字后比较
            -true、false转化为1、0后比较
            -一个对象，一个基础类型，会把对象用toString()或valueOf()方法
            -任何其他组合都不相等

详解js中的undefined、NaN、null
    1.undefined:变量声明了但没有赋值
        -undefined参与运算后，结果为NaN
        -type of undefined //undefined
    2.NaN:不是一个数字
        -参与一个运算，得到结果NaN :
        -NaN和任何数都不相等，包裹自己
        -typeof NaN  //number
    3.null：空的状态
        -参与运算时转化为0
        -参与比较时转化为NaN
        -typeof Null   //object   (特性)
        -null instance of Object //(false)

    总结：undefined === NaN   false 
         null == NaN         false
         null === undefined  false
         null == undefined   true

