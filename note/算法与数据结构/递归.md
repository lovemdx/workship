
递归：
    大问题拆分成小问题，且大问题和子问题的问题结构是类似的。是大化多个小的问题。
    具体操作上，是自己调用自己，阻塞自己等待递归函数返回值

    Master公式：
        定义：T(N)=a*T(N/b)+O(N^d)    当logba<d  O（d^N） logba>d O(N^logba)   logba==d O(N^d*log2N)
            d:在一层递归里干的额外事情的复杂度是
            a:递归了几层
            b:递归把大问题分了几段
        用处：用来分析递归函数的时间复杂度的
        估计的目标：递归的子问题规模一致


哈希表hashmap
    实现：key-value。
        -如果哈希表key/value非基础类型，只会记录地址
    哈希表优点：不管内部数据量多大，增加、删除、查询都是O(1)
        java中，基本类型按值传递，非基本类型引用传递

有序表Treemap  红黑树实现
    优点：增删改查 是O(log2N)
        在哈希表的基础上，还有一些功能：最小key，最大key，大于某个值最小的key等。

    注意：原生类型指导如何培训，自定义类型不知道如何排序，会出错。

归并(递归合并)排序
    实现：以中点为界限，先让L有序，再让R有序，再merge
        -用辅助数组merge
    两种实现：一种递归实现，
            一种循环实现：步长每次翻倍，然后merge



